{% extends "base.html" %}
{% block title %}チェスクロック方式 | 読み上げ対局時計{% endblock %}
{% block content %}
<style>
  :root{
    --danger:#e11d48;        /* 秒読み/切れ負けの赤 */
    --active-blue:#0666ff;   /* 手番ハイライトの青 */
  }
  *{box-sizing:border-box}
  /* 和紙+明朝は base.html に委ねる（ここで上書きしない） */

  h1{font-size:20px;margin:8px 0 12px}
  .muted{color:var(--muted);margin:0 0 16px}

  .row{display:flex;gap:16px;align-items:stretch;flex-wrap:wrap}
  .col,.group{display:flex;flex-direction:column;gap:8px;min-width:260px}
  .boards{display:flex;gap:16px;flex-wrap:wrap}
  @media (orientation:portrait){ .boards{flex-direction:column} }
  .boards.reverse{flex-direction:row-reverse}
  @media (orientation:portrait){ .boards.reverse{flex-direction:column-reverse} }

  /* 和風カード寄せ */
  .card{
    border:2px solid var(--accent);
    border-radius:var(--radius);
    padding:14px 16px;
    flex:1; min-width:280px;
    background: var(--card);
    box-shadow: 2px 4px 10px rgba(0,0,0,.10);
    transition: border-color .15s ease, box-shadow .15s ease, background .15s ease;
  }
  .card.active{
    border-color: var(--active-blue);
    box-shadow: 0 0 0 3px rgba(6,102,255,.18);
    background:
      linear-gradient(180deg, rgba(255,255,255,.70), rgba(255,255,255,.55)),
      var(--paper);
  }

  .controlsSection{margin-top:18px}
  .controlsCard{
    max-width:980px;width:100%;
    border:2px solid var(--accent);
    border-radius:var(--radius);
    background:var(--card);
    padding:12px 16px 14px;
    box-shadow: 2px 4px 10px rgba(0,0,0,.10);
  }
  @media (min-width:640px){ .controlsCard{position:sticky;bottom:0} }

  .title{font-weight:800;margin-bottom:6px;letter-spacing:.02em}

  /* 数字は読みやすさ優先でゴシック＆等幅風 */
  .remain{
    font-family: system-ui, "Noto Sans JP", "Yu Gothic", sans-serif;
    font-size:46px; line-height:1.2;
    font-variant-numeric: tabular-nums; letter-spacing:.02em;
  }

  /* 秒読み=赤（普通太さ）、時間切れ=赤い太字 */
  .remain.red{ color: var(--danger); font-weight: 400; }
  .remain.dead{ color: var(--danger); font-weight: 800; }

  input[type=number], select{
    width:120px;padding:8px 10px;border-radius:8px;border:1px solid var(--accent);background:#fff;outline:none
  }
  input[type=number]:focus, select:focus{ box-shadow: 0 0 0 3px rgba(122,143,82,.25); border-color: var(--accent); }

  .field{display:flex;flex-direction:column;gap:6px}
  .field + .field{margin-top:6px}

  button{
    padding:10px 14px;border-radius:12px;border:1.5px solid var(--accent);background:#fff;cursor:pointer;user-select:none;font-weight:700
  }
  button.primary{ border-color: var(--active-blue); color: var(--active-blue); background: linear-gradient(180deg,#fff,#fffdf6); }
  button.danger{ border-color: var(--danger); color: var(--danger); }
  button:focus-visible{ outline:none; box-shadow: 0 0 0 3px rgba(122,143,82,.25); }
</style>

<h1>読み上げ対局時計（チェスクロック方式）</h1>
<p class="muted">
  ルール：<strong>持ち時間内は読み上げ無し</strong>。<br>
  秒読みに入ったら<strong>経過秒で「○秒」</strong>を読み上げ。
</p>

<!-- 設定パネル（統一/個別） -->
<div class="card">
  <div class="row" style="align-items:center; gap:12px 16px;">
    <button id="btnUnify" class="primary">先手・後手で統一する</button>
    <span id="unifyHint" class="muted">（オフ）</span>
  </div>
  <div class="row settings">
    <div class="col" id="groupA">
      <div class="title" id="titleA">先手 設定</div>
      <div class="field"><label>初期：時間</label><input type="number" id="setAh" min="0" max="24" step="1" value="0"></div>
      <div class="field"><label>初期：分</label><input type="number" id="setAm" min="0" max="59" step="1" value="5"></div>
      <div class="field"><label>秒読み（秒）</label><select id="byoyomiA"></select></div>
    </div>
    <div class="col" id="groupB">
      <div class="title">後手 設定</div>
      <div class="field"><label>初期：時間</label><input type="number" id="setBh" min="0" max="24" step="1" value="0"></div>
      <div class="field"><label>初期：分</label><input type="number" id="setBm" min="0" max="59" step="1" value="5"></div>
      <div class="field"><label>秒読み（秒）</label><select id="byoyomiB"></select></div>
    </div>
    <div class="col">
      <div class="title">読み上げ</div>
      <label>声</label>
      <select id="voicePref">
        <option value="male" selected>男性</option>
        <option value="female">女性</option>
      </select>
      <div style="margin-top:10px"><button class="primary" id="btnApply">適用</button></div>
    </div>
  </div>
</div>

<!-- 盤面表示 -->
<div class="row boards" id="boards">
  <div id="cardA" class="card" role="button" aria-label="先手の時計（自分の番でタップすると着手）">
    <div class="title">先手 残り</div>
    <div id="remainA" class="remain">5:00</div>
  </div>
  <div id="cardB" class="card" role="button" aria-label="後手の時計（自分の番でタップすると着手）">
    <div class="title">後手 残り</div>
    <div id="remainB" class="remain">5:00</div>
  </div>
</div>

<!-- 下コントロール -->
<div class="controlsSection">
  <div id="controlsCard" class="controlsCard card">
    <div class="row" style="align-items:center;justify-content:space-between;">
      <div class="title">手番：<span id="turn">先手</span></div>
      <button id="btnSwap">左右/上下 入れ替え</button>
    </div>
    <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;">
      <button class="primary" id="btnStart">スタート / 再開</button>
      <button id="btnStop">一時停止</button>
      <button id="btnSwitch">手番切替（Enter）</button>
      <button class="danger" id="btnNew">新しく始める（設定値で）</button>
    </div>
  </div>
</div>

<script>
// ===== ユーティリティ =====
const q=id=>document.getElementById(id);
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,Number(v)||0));
function fmtClock(ms){ if(ms<0) ms=0; const s=Math.floor(ms/1000); const m=Math.floor(s/60); const r=s%60; return `${m}:${String(r).padStart(2,'0')}`; }

// ===== セレクト生成 =====
function buildByo(sel){ sel.innerHTML=''; [20,30,40,50,60].forEach(s=>{ const o=document.createElement('option'); o.value=String(s); o.textContent=`${s}秒`; sel.appendChild(o); }); sel.value='30'; }

// ===== 統一トグル =====
let unify=false; // true=統一（先手の値→後手へミラー）
function updateSettingsUI(){
  q('groupB').style.display = unify ? 'none' : '';
  q('titleA').textContent   = unify ? '設定' : '先手 設定';
  q('btnUnify').textContent = unify ? '統一を解除する' : '先手・後手で統一する';
  q('unifyHint').textContent= unify ? '（オン：先手設定が両方に適用）' : '（オフ）';
}
function syncBfromA(){ q('setBh').value=q('setAh').value; q('setBm').value=q('setAm').value; q('byoyomiB').value=q('byoyomiA').value; }
q('btnUnify').addEventListener('click',()=>{ unify=!unify; if(unify) syncBfromA(); updateSettingsUI(); });
['setAh','setAm','byoyomiA'].forEach(id=>{ q(id).addEventListener('input',()=>{ if(unify) syncBfromA(); }); q(id).addEventListener('change',()=>{ if(unify) syncBfromA(); }); });

// ===== 状態 =====
let current='A';
let msLeft={A:5*60*1000, B:5*60*1000};
let inByo={A:false,B:false};
let timeUp={A:false,B:false};
let byoA=30, byoB=30;
let ticking=false, stepTimer=null, nextAt=0, lastSwitchAt=0;
let markersSpoken={A:new Set(), B:new Set()};

// ===== 音声 =====
let voices=[], selectedVoice=null, voicePref='male';
function loadVoices(){ if(!('speechSynthesis'in window)) return; const all=speechSynthesis.getVoices(); voices=all.filter(v=>(v.lang||'').toLowerCase().startsWith('ja'))||all; pickVoice(); }
function pickVoice(){ if(!voices.length) return; const female=['Kyoko','Kyōko','Mizuki','Nozomi','Sayaka','Ayumi','Hina','Yuri','Akiko','Female','女性']; const male=['Otoya','Ichiro','Taro','Hattori','Kenji','Hideo','Takeo','Male','男性']; const m=(v,h)=>((v.name||'')+' '+(v.voiceURI||'')).toLowerCase().includes(h.toLowerCase()); selectedVoice=(voicePref==='female')?(voices.find(v=>female.some(h=>m(v,h)))||voices.find(v=>/female/i.test(v.name))||voices[0]):(voices.find(v=>male.some(h=>m(v,h)))||voices.find(v=>/male/i.test(v.name))||voices[0]); }
if(typeof speechSynthesis!=='undefined'){ speechSynthesis.onvoiceschanged=loadVoices; setTimeout(loadVoices,0); }
q('voicePref').addEventListener('change', e=>{ voicePref=e.target.value; pickVoice(); });
function speak(t,{rate=1.06}={}){ if(!window.speechSynthesis) return; const u=new SpeechSynthesisUtterance(t); u.lang=(selectedVoice&&selectedVoice.lang)||'ja-JP'; u.voice=selectedVoice||null; u.rate=rate; u.pitch=1; u.volume=1; speechSynthesis.speak(u); }
function speakStrict(t,rate=1.12){ if(!window.speechSynthesis) return; try{speechSynthesis.cancel();speechSynthesis.resume?.();}catch(e){} const u=new SpeechSynthesisUtterance(t); u.lang=(selectedVoice&&selectedVoice.lang)||'ja-JP'; u.voice=selectedVoice||null; u.rate=rate; u.pitch=1; u.volume=1; speechSynthesis.speak(u); }
function speakNum(n){ const map={1:'いち',2:'に',3:'さん',4:'し',5:'ご',6:'ろく',7:'しち',8:'はち',9:'きゅう'}; speakStrict(map[n]||String(n),1.12); }

// ===== 経過マーカー（経過秒でコール） =====
function elapsedMarkersFor(byo){
  switch(byo){
    case 60: return [30,40,50];
    case 50: return [20,30,40];
    case 40: return [10,20,30];
    case 30: return [10,20];
    case 20: return [10];
    default: return [];
  }
}

// ===== UI描画 =====
function updateUI(){
  ['A','B'].forEach(p=>{
    const el=q('remain'+p);
    if(timeUp[p]){
      el.textContent='時間切れ';
      el.classList.add('dead','red');
      return;
    }
    el.classList.remove('dead');
    if(inByo[p]){
      const rs = Math.floor(msLeft[p]/1000); // ★表示と読み上げの基準を統一（floor）
      el.textContent= Math.max(0, rs) + '秒';
      el.classList.add('red');
    } else {
      el.textContent=fmtClock(msLeft[p]);
      el.classList.remove('red');
    }
  });
  q('cardA').classList.toggle('active', current==='A'&&!timeUp.A);
  q('cardB').classList.toggle('active', current==='B'&&!timeUp.B);
  q('turn').textContent=(current==='A'?'先手':'後手');
}

// ===== 進行ループ（秒境界に同期） =====
function alignNextTick(){ const now=Date.now(); nextAt=Math.ceil(now/1000)*1000; }
function scheduleStep(){ if(!ticking) return; stepTimer=setTimeout(step, Math.max(0,nextAt-Date.now())); }
function step(){ if(!ticking) return; tick(); nextAt+=1000; scheduleStep(); }
function startClock(){ if(ticking||timeUp.A||timeUp.B) return; ticking=true; alignNextTick(); scheduleStep(); }
function stopClock(){ ticking=false; clearTimeout(stepTimer); }

// ===== 読み上げ（経過秒ベース） =====
function maybeAnnounceByo(p){
  const byo = (p==='A'?byoA:byoB);
  const remainSec = Math.max(0, Math.floor(msLeft[p]/1000)); // ★UIと同じfloor
  const elapsedSec = Math.max(0, byo - remainSec);
  const spoken = markersSpoken[p];

  if(remainSec >= 10){
    const marks = elapsedMarkersFor(byo);
    if(marks.includes(elapsedSec) && !spoken.has('e'+elapsedSec)){
      spoken.add('e'+elapsedSec);
      speakStrict(`${elapsedSec}秒`, 1.12);
    }
  } else if(remainSec >= 1){
    // ラスト9秒：表示 9/8/.. に対して 1/2/.. を読む（1秒ズレ防止のため remainSec を基準に算出）
    const n = 10 - remainSec; // 9残→1, ... ,1残→9
    const key = 'final-'+n;
    if(!spoken.has(key)){
      spoken.add(key);
      speakNum(n);
    }
  }
}

function tick(){
  if(timeUp.A||timeUp.B){ stopClock(); return; }
  // ★先に残時間を1秒分減らす→この値を基準にUIと読み上げを一致させる
  msLeft[current]-=1000;

  if(msLeft[current] <= 0){
    if(!inByo[current]){
      // メイン→秒読み（無発声で移行）
      inByo[current]=true;
      msLeft[current]=((current==='A'?byoA:byoB))*1000;  // 満額セット
      markersSpoken[current].clear();
    }else{
      // 秒読みで0 → 時間切れ
      msLeft[current]=0; timeUp[current]=true;
      speakStrict('時間切れです',1.05);
      stopClock();
    }
  }

  if(!timeUp[current] && inByo[current]) maybeAnnounceByo(current);
  updateUI();
}

// ===== 手番切替（自分側のみ） =====
function switchTurn(){
  if(timeUp.A||timeUp.B) return;
  const now=Date.now(); if(now-lastSwitchAt<200) return; lastSwitchAt=now;
  stopClock();
  // 秒読み中は着手で満額に戻す（読み上げマーカーもリセット）
  if(inByo[current]){
    msLeft[current]=((current==='A'?byoA:byoB))*1000;
    markersSpoken[current].clear();
  }
  current=(current==='A'?'B':'A');
  alignNextTick(); updateUI(); startClock();
}

// ===== 設定反映 =====
function readSettings(){
  const Ah=clamp(q('setAh').value,0,24), Am=clamp(q('setAm').value,0,59);
  const Bh=clamp(q('setBh').value,0,24), Bm=clamp(q('setBm').value,0,59);
  byoA=Number(q('byoyomiA').value)||30;
  byoB = unify ? byoA : (Number(q('byoyomiB').value)||30);

  msLeft.A=(Ah*60+Am)*60*1000;
  msLeft.B=(unify?(Ah*60+Am):(Bh*60+Bm))*60*1000;

  timeUp={A:false,B:false};
  inByo={A:false,B:false};
  markersSpoken={A:new Set(),B:new Set()};

  // 0開始なら即・秒読み（無発声で満額セット）
  if(msLeft.A===0){ inByo.A=true; msLeft.A=byoA*1000; }
  if(msLeft.B===0){ inByo.B=true; msLeft.B=byoB*1000; }

  current='A';
}
function applySettings(){ stopClock(); try{speechSynthesis.cancel();}catch(e){} if(unify) syncBfromA(); readSettings(); updateUI(); }

// ===== 初期化/イベント =====
buildByo(q('byoyomiA')); buildByo(q('byoyomiB'));
q('btnStart').addEventListener('click', startClock);
q('btnStop').addEventListener('click', stopClock);
q('btnSwitch').addEventListener('click', switchTurn);
q('btnNew').addEventListener('click', applySettings);
q('btnApply').addEventListener('click', applySettings);
q('cardA').addEventListener('click', ()=>{ if(current==='A') switchTurn(); });
q('cardB').addEventListener('click', ()=>{ if(current==='B') switchTurn(); });
q('btnSwap').addEventListener('click', ()=>{ const boards=q('boards'); boards.insertBefore(boards.lastElementChild, boards.firstElementChild); });
window.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); switchTurn(); }});

updateSettingsUI();
applySettings();
</script>
{% endblock %}
