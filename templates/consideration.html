{% extends "base.html" %}
{% block title %}考慮時間方式 | 読み上げ対局時計（完全版）{% endblock %}
{% block content %}
<style>
  :root{ --danger:#e11d48; --active-blue:#0666ff; }
  *{ box-sizing:border-box }
  h1{font-size:20px;margin:8px 0 12px}
  .muted{color:var(--muted);margin:0 0 16px}

  .row{display:flex;gap:16px;align-items:stretch;flex-wrap:wrap}
  .col,.group{display:flex;flex-direction:column;gap:8px;min-width:260px}
  .boards{display:flex;gap:16px;flex-wrap:wrap}
  @media (orientation:portrait){ .boards{flex-direction:column} }
  .boards.reverse{flex-direction:row-reverse}
  @media (orientation:portrait){ .boards.reverse{flex-direction:column-reverse} }

  .card{
    border:2px solid var(--accent);
    border-radius:var(--radius);
    padding:14px 16px;
    flex:1; min-width:280px;
    background:var(--card);
    box-shadow:2px 4px 10px rgba(0,0,0,.10);
    transition:border-color .15s ease, box-shadow .15s ease, background .15s ease;
  }
  .card.active{
    border-color:var(--active-blue);
    box-shadow:0 0 0 3px rgba(6,102,255,.18);
    background:
      linear-gradient(180deg, rgba(255,255,255,.70), rgba(255,255,255,.55)),
      var(--paper);
  }

  .controlsSection{margin-top:18px}
  .controlsCard{
    max-width:980px;width:100%;
    border:2px solid var(--accent);
    border-radius:var(--radius);
    background:var(--card);
    padding:12px 16px 14px;
    box-shadow:2px 4px 10px rgba(0,0,0,.10);
  }
  @media (min-width:640px){ .controlsCard{position:sticky;bottom:0} }

  .title{font-weight:800;margin-bottom:6px;letter-spacing:.02em}

  .remain{
    font-family: system-ui, "Noto Sans JP", "Yu Gothic", sans-serif;
    font-size:46px; line-height:1.2;
    font-variant-numeric: tabular-nums; letter-spacing:.02em;
  }
  .remain.red{ color:var(--danger); font-weight:400; }
  .remain.dead{ color:var(--danger); font-weight:800; }

  input[type=number], select{
    width:120px;padding:8px 10px;border-radius:8px;border:1px solid var(--accent);background:#fff;outline:none
  }
  input[type=number]:focus, select:focus{
    box-shadow:0 0 0 3px rgba(122,143,82,.25); border-color:var(--accent)
  }

  .field{display:flex;flex-direction:column;gap:6px}
  .field + .field{margin-top:6px}

  button{
    padding:10px 14px;border-radius:12px;border:1.5px solid var(--accent);background:#fff;cursor:pointer;user-select:none;font-weight:700
  }
  button.primary{ border-color: var(--active-blue); color: var(--active-blue); background: linear-gradient(180deg,#fff,#fffdf6) }
  button.danger{ border-color: var(--danger); color: var(--danger) }
  button:focus-visible{ outline:none; box-shadow: 0 0 0 3px rgba(122,143,82,.25) }

  /* 「考慮時間残◯回」を少し大きく見やすく */
  .cons-left{ font-size:16px; font-weight:600; }
</style>

<h1>読み上げ対局時計（考慮時間方式）</h1>
<p class="muted">
  持ち時間が切れたら<strong>秒読み</strong>へ。秒読みで指せなかった場合に<strong>考慮時間</strong>（設定回数ぶん）を消費。<br>
  ※考慮は<strong>同一手番で連続使用可</strong>（例：30秒×3回）。
</p>

<!-- 設定パネル -->
<div class="card">
  <div class="row" style="align-items:center; gap:12px 16px;">
    <button id="btnUnify" class="primary">先手・後手で統一する</button>
    <span id="unifyHint" class="muted">（オフ）</span>
  </div>
  <div class="row settings">
    <div class="col" id="groupA">
      <div class="title" id="titleA">先手 設定</div>
      <div class="field"><label>初期：時間</label><input type="number" id="setAh" min="0" max="24" step="1" value="0"></div>
      <div class="field"><label>初期：分</label><input type="number" id="setAm" min="0" max="59" step="1" value="5"></div>
      <div class="field"><label>秒読み（秒）</label><select id="byoyomiA"></select></div>
      <div class="field"><label>考慮時間（秒）</label><select id="consA"></select></div>
      <div class="field"><label>考慮回数</label><input type="number" id="consCountA" min="0" max="99" step="1" value="3"></div>
    </div>
    <div class="col" id="groupB">
      <div class="title">後手 設定</div>
      <div class="field"><label>初期：時間</label><input type="number" id="setBh" min="0" max="24" step="1" value="0"></div>
      <div class="field"><label>初期：分</label><input type="number" id="setBm" min="0" max="59" step="1" value="5"></div>
      <div class="field"><label>秒読み（秒）</label><select id="byoyomiB"></select></div>
      <div class="field"><label>考慮時間（秒）</label><select id="consB"></select></div>
      <div class="field"><label>考慮回数</label><input type="number" id="consCountB" min="0" max="99" step="1" value="3"></div>
    </div>
    <div class="col">
      <div class="title">読み上げ</div>
      <label>声</label>
      <select id="voicePref">
        <option value="male" selected>男性</option>
        <option value="female">女性</option>
      </select>
      <div style="margin-top:10px"><button class="primary" id="btnApply">適用</button></div>
    </div>
  </div>
</div>

<!-- 盤面表示 -->
<div class="row boards" id="boards">
  <div id="cardA" class="card" role="button" aria-label="先手の時計（自分の番でタップすると着手）">
    <div class="title">先手 残り</div>
    <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
      <div id="remainA" class="remain">5:00</div>
      <div id="consRemainA" class="muted cons-left">考慮時間残3回</div>
    </div>
  </div>
  <div id="cardB" class="card" role="button" aria-label="後手の時計（自分の番でタップすると着手）">
    <div class="title">後手 残り</div>
    <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
      <div id="remainB" class="remain">5:00</div>
      <div id="consRemainB" class="muted cons-left">考慮時間残3回</div>
    </div>
  </div>
</div>

<!-- 下コントロール -->
<div class="controlsSection">
  <div id="controlsCard" class="controlsCard card">
    <div class="row" style="align-items:center;justify-content:space-between;">
      <div class="title">手番：<span id="turn">先手</span></div>
      <button id="btnSwap">左右/上下 入れ替え</button>
    </div>
    <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;">
      <button class="primary" id="btnStart">スタート / 再開</button>
      <button id="btnStop">一時停止</button>
      <button id="btnSwitch">手番切替（Enter）</button>
      <button class="danger" id="btnNew">新しく始める（設定値で）</button>
    </div>
  </div>
</div>

<script>
/* ===== ユーティリティ ===== */
const q=id=>document.getElementById(id);
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,Number(v)||0));
function fmtClock(ms){ if(ms<0) ms=0; const s=Math.floor(ms/1000); const m=Math.floor(s/60); const r=s%60; return `${m}:${String(r).padStart(2,'0')}`; }

/* ===== セレクト生成 ===== */
function buildSecSelect(sel){ sel.innerHTML='';
  [10,20,30,40,50,60].forEach(s=>{ const o=document.createElement('option'); o.value=String(s); o.textContent=`${s}秒`; sel.appendChild(o); });
  sel.value='30';
}

/* ===== 統一トグル ===== */
let unify=false;
function updateSettingsUI(){
  q('groupB').style.display = unify ? 'none' : '';
  q('titleA').textContent   = unify ? '設定' : '先手 設定';
  q('btnUnify').textContent = unify ? '統一を解除する' : '先手・後手で統一する';
  q('unifyHint').textContent= unify ? '（オン：先手設定が両方に適用）' : '（オフ）';
}
function syncBfromA(){
  q('setBh').value=q('setAh').value; q('setBm').value=q('setAm').value;
  q('byoyomiB').value=q('byoyomiA').value; q('consB').value=q('consA').value; q('consCountB').value=q('consCountA').value;
}
q('btnUnify').addEventListener('click',()=>{ unify=!unify; if(unify) syncBfromA(); updateSettingsUI(); });
['setAh','setAm','byoyomiA','consA','consCountA'].forEach(id=>{
  q(id).addEventListener('input',()=>{ if(unify) syncBfromA(); });
  q(id).addEventListener('change',()=>{ if(unify) syncBfromA(); });
});

/* ===== 状態 ===== */
let current='A';
let mainMs={A:5*60*1000, B:5*60*1000};
let segMs ={A:0, B:0};           // 秒読み or 考慮の残り（ms）
let mode  ={A:'main', B:'main'}; // 'main' | 'byo' | 'cons'
let byoSec={A:30, B:30};
let consSec={A:30, B:30};
let consRemain={A:3, B:3};       // 考慮残回数（0=もう無い）
let isFinalCons={A:false, B:false};

let announcedEnterByo={A:false,B:false};
let timeUp={A:false,B:false};
let ticking=false, stepTimer=null, nextAt=0, lastSwitchAt=0;
const SWITCH_COOLDOWN_MS=200;

/* 読み上げ用メモ */
let markersSpoken={A:{byo:new Set(),cons:new Set()}, B:{byo:new Set(),cons:new Set()}};

/* ラスト9秒カウントアップ（interval方式） */
let lastCountdownFlag={A:false,B:false};
let finalInterval={A:null,B:null};
let finalCount   ={A:0,   B:0};

/* ===== 音声 ===== */
let voices=[], selectedVoice=null, voicePref='male';
function loadVoices(){ if(!('speechSynthesis'in window)) return;
  const all=speechSynthesis.getVoices();
  voices=all.filter(v=>(v.lang||'').toLowerCase().startsWith('ja'))||all; pickVoice();
}
function pickVoice(){
  if(!voices.length) return;
  const female=['Kyoko','Kyōko','Mizuki','Nozomi','Sayaka','Ayumi','Hina','Yuri','Akiko','Female','女性'];
  const male  =['Otoya','Ichiro','Taro','Hattori','Kenji','Hideo','Takeo','Male','男性'];
  const m=(v,h)=>((v.name||'')+' '+(v.voiceURI||'')).toLowerCase().includes(h.toLowerCase());
  selectedVoice=(voicePref==='female')
    ? (voices.find(v=>female.some(h=>m(v,h)))||voices.find(v=>/female/i.test(v.name))||voices[0])
    : (voices.find(v=>male.some(h=>m(v,h)))  ||voices.find(v=>/male/i.test(v.name))  ||voices[0]);
}
if(typeof speechSynthesis!=='undefined'){ speechSynthesis.onvoiceschanged=loadVoices; setTimeout(loadVoices,0); }
q('voicePref').addEventListener('change', e=>{ voicePref=e.target.value; pickVoice(); });

function speak(t,{rate=1.06}={}){ if(!window.speechSynthesis) return; const u=new SpeechSynthesisUtterance(t);
  u.lang=(selectedVoice&&selectedVoice.lang)||'ja-JP'; u.voice=selectedVoice||null; u.rate=rate; u.pitch=1; u.volume=1; speechSynthesis.speak(u);
}
function speakStrict(t,rate=1.12){ if(!window.speechSynthesis) return;
  try{speechSynthesis.cancel();speechSynthesis.resume?.();}catch(e){}
  const u=new SpeechSynthesisUtterance(t); u.lang=(selectedVoice&&selectedVoice.lang)||'ja-JP'; u.voice=selectedVoice||null; u.rate=rate; u.pitch=1; u.volume=1; speechSynthesis.speak(u);
}
/* 指定読み：４=し、７=しち */
function speakNum(n){
  const map={1:'いち',2:'に',3:'さん',4:'し',5:'ご',6:'ろく',7:'しち',8:'はち',9:'きゅう'};
  speakStrict(map[n]||String(n),1.12);
}

/* ===== 経過マーカー（経過秒でコール） ===== */
function elapsedMarkersFor(total){
  switch(total){
    case 60: return [30,40,50,55];
    case 50: return [20,30,40,45];
    case 40: return [10,20,30,35];
    case 30: return [10,20,25];
    case 20: return [10,15];
    case 10: return [5];
    default: return [];
  }
}

/* ===== ラスト9秒：到達後に1→9のカウントアップ ===== */
function clearFinal(p){
  if(finalInterval[p]!==null){ clearInterval(finalInterval[p]); finalInterval[p]=null; }
  finalCount[p]=0; lastCountdownFlag[p]=false;
}
function scheduleFinalFrom(p,startSec){
  if(lastCountdownFlag[p]) return;
  clearFinal(p);
  lastCountdownFlag[p]=true;
  finalCount[p]=0;

  const speakNext=()=>{
    // 条件は常に監視：外れたら即停止
    const stillFinalWindow = (mode[p]==='byo' && consRemain[p]===0) || (mode[p]==='cons' && isFinalCons[p]);
    if(!ticking || timeUp[p] || current!==p || mode[p]==='main' || !stillFinalWindow){
      clearFinal(p); return;
    }
    finalCount[p]+=1; speakNum(finalCount[p]);
    if(finalCount[p]>=startSec){ clearFinal(p); } // 0到達時の「時間切れです」は step() が言う
  };

  speakNext(); // 即「1」
  finalInterval[p]=setInterval(speakNext,1000);
}
function maybeScheduleFinal(p){
  if(lastCountdownFlag[p] || segMs[p]<=0) return;
  const remainSec=Math.floor(segMs[p]/1000);
  const isFinalWindow=(mode[p]==='byo' && consRemain[p]===0) || (mode[p]==='cons' && isFinalCons[p]);
  if(isFinalWindow && remainSec<=9){
    scheduleFinalFrom(p, Math.min(9, Math.max(1, remainSec)));
  }
}
function clearAllFinal(){ clearFinal('A'); clearFinal('B'); }

/* ===== UI更新 ===== */
function secText(ms){ return Math.max(0,Math.floor(ms/1000))+"秒"; }
function updateUI(){
  ['A','B'].forEach(p=>{
    const el=q('remain'+p);
    if(timeUp[p]){
      el.textContent='時間切れ';
      el.classList.add('dead','red');
    }else{
      el.classList.remove('dead');
      if(mode[p]==='main'){
        el.textContent=fmtClock(mainMs[p]);
        el.classList.remove('red'); // 通常は赤くしない
      }else{
        el.textContent=secText(segMs[p]);
        // 赤は「考慮なしの秒読み」or「最後の考慮」だけ
        const forceRed=(mode[p]==='byo' && consRemain[p]===0) || (mode[p]==='cons' && isFinalCons[p]);
        el.classList.toggle('red', forceRed);
      }
    }
    q('consRemain'+p).textContent=`考慮時間残${consRemain[p]}回`;
  });
  q('turn').textContent=(current==='A'?'先手':'後手');
  q('cardA').classList.toggle('active', current==='A');
  q('cardB').classList.toggle('active', current==='B');
}

/* ===== 入場ヘルパー ===== */
function enterByo(p){
  mode[p]='byo';
  segMs[p]=byoSec[p]*1000;
  announcedEnterByo[p]=true;
  markersSpoken[p].byo.clear();
  clearFinal(p); // 入場時は予約しない（9秒域で動的予約）
}
function startConsideration(p){
  mode[p]='cons';
  isFinalCons[p]=(consRemain[p]===1);
  segMs[p]=consSec[p]*1000;
  consRemain[p]--;
  markersSpoken[p].cons.clear();
  if(consRemain[p]>0) speak(`考慮時間残り${consRemain[p]}回です`,{rate:1.06});
  else speak('考慮時間残りありません',{rate:1.06});
  clearFinal(p); // 入場時は予約しない（9秒域で動的予約）
}

/* ===== 完全停止（適用/新規/一時停止で使用） ===== */
function stopClock(){
  ticking=false;
  if(stepTimer){ clearTimeout(stepTimer); stepTimer=null; }
  clearAllFinal();
  try{ window.speechSynthesis && speechSynthesis.cancel(); }catch(e){}
}

/* ===== 入力適用 ===== */
function applyFromInputs(){
  const Ah=clamp(q('setAh').value,0,24), Am=clamp(q('setAm').value,0,59);
  const Bh=clamp(q('setBh').value,0,24), Bm=clamp(q('setBm').value,0,59);
  byoSec.A=clamp(q('byoyomiA').value,10,60);
  byoSec.B=clamp(q('byoyomiB').value,10,60);
  consSec.A=clamp(q('consA').value,10,60);
  consSec.B=clamp(q('consB').value,10,60);
  consRemain.A=clamp(q('consCountA').value,0,99);
  consRemain.B=clamp(q('consCountB').value,0,99);

  mainMs.A=((Ah*60)+Am)*1000*60;
  mainMs.B=((Bh*60)+Bm)*1000*60;
  segMs.A=segMs.B=0;
  mode.A=mode.B='main';
  isFinalCons.A=isFinalCons.B=false;
  announcedEnterByo.A=announcedEnterByo.B=false;
  timeUp.A=timeUp.B=false;

  markersSpoken.A.byo.clear(); markersSpoken.A.cons.clear();
  markersSpoken.B.byo.clear(); markersSpoken.B.cons.clear();
  clearAllFinal();

  current='A';
  updateUI();
}
function newGame(){ applyFromInputs(); }

/* ===== 盤面向き ===== */
function swapBoards(){ q('boards').classList.toggle('reverse'); }

/* ===== 秒境界同期タイマー ===== */
function alignNextTick(){ const now=Date.now(); nextAt=Math.ceil(now/1000)*1000; }
function scheduleStep(){ if(!ticking) return; stepTimer=setTimeout(step, Math.max(0, nextAt - Date.now())); }

/* ===== 手番切替（着手） ===== */
function switchTurn(manual=true){
  const now=Date.now();
  if(now-lastSwitchAt < SWITCH_COOLDOWN_MS) return;
  lastSwitchAt=now;
  if(timeUp[current]) return;

  const me=current;

  // 着手した瞬間の自分側処理：次回の自分は常に秒読み満タン
  if(mode[me]==='byo'){
    if(segMs[me]>0){ enterByo(me); } else { if(consRemain[me]>0) startConsideration(me); else timeUp[me]=true; }
  }else if(mode[me]==='cons'){
    if(segMs[me]>0){ enterByo(me); } else { if(consRemain[me]>0) startConsideration(me); else timeUp[me]=true; }
  } // mainはそのまま

  if(timeUp[me]){ updateUI(); return; }

  // 相手へ
  current=(current==='A'?'B':'A');
  const opp=current;

  // 相手がメイン切れなら秒読み入場
  if(mode[opp]==='main' && mainMs[opp]<=0){ enterByo(opp); }

  updateUI();
}

/* ===== 読み上げロジック ===== */
function handleAnnouncements(p, beforeMs, afterMs){
  if(mode[p]==='byo' && announcedEnterByo[p]){
    announcedEnterByo[p]=false;
    // 必要なら「秒読み◯秒です」を発話可能
  }
  if(mode[p]==='byo' || mode[p]==='cons'){
    const total=(mode[p]==='byo')?byoSec[p]:consSec[p];
    const set  =(mode[p]==='byo')?markersSpoken[p].byo:markersSpoken[p].cons;
    const elapsedBefore = total - Math.floor(beforeMs/1000);
    const elapsedAfter  = total - Math.floor(afterMs /1000);

    for(const m of elapsedMarkersFor(total)){
      if(elapsedBefore < m && elapsedAfter >= m && !set.has(m)){
        set.add(m); speak(`${m}秒`,{rate:1.06});
      }
    }
    if(afterMs<=0){ speak('時間切れです',{rate:1.06}); }
  }
}

/* ===== 1秒ごと進行 ===== */
function step(){
  if(!ticking){ stepTimer=null; return; }
  const p=current;

  let beforeMain=mainMs[p], beforeSeg=segMs[p];

  if(mode[p]==='main'){
    mainMs[p]-=1000;
    if(mainMs[p]<=0){ mainMs[p]=0; enterByo(p); }
  }else{
    segMs[p]-=1000;
    if(segMs[p]<=0){
      segMs[p]=0;
      if(mode[p]==='byo'){
        if(consRemain[p]>0){ startConsideration(p); } else { timeUp[p]=true; }
      }else if(mode[p]==='cons'){
        if(consRemain[p]>0){ startConsideration(p); } else { timeUp[p]=true; }
      }
    }
  }

  // 9秒域検知（対象時のみ）→ 1→9 カウントアップ予約
  if(mode[p]!=='main'){ maybeScheduleFinal(p); }

  // 読み上げ
  const afterMain=mainMs[p], afterSeg=segMs[p];
  const before=(mode[p]==='main')?beforeMain:beforeSeg;
  const after =(mode[p]==='main')?afterMain :afterSeg;
  handleAnnouncements(p, before, after);

  // UI
  updateUI();

  if(timeUp[p]){ ticking=false; stepTimer=null; return; }

  // 次の1秒境界へ
  nextAt += 1000;
  scheduleStep();
}

/* ===== ボタン配線 ===== */
q('btnApply').addEventListener('click', ()=>{
  stopClock();        // ★必ず停止
  applyFromInputs();  // 値反映のみ（ここでは走らない）
  updateUI();
});
q('btnNew').addEventListener('click', ()=>{
  stopClock();  // ★必ず停止
  newGame();    // 設定値で初期化
  updateUI();
});
q('btnStart').addEventListener('click', ()=>{
  if(ticking) return;
  ticking=true;
  alignNextTick();
  scheduleStep();
});
q('btnStop').addEventListener('click', ()=>{ stopClock(); });
q('btnSwitch').addEventListener('click', ()=>{ switchTurn(true); });
q('btnSwap').addEventListener('click', ()=>{ swapBoards(); });

['cardA','cardB'].forEach(id=>{
  q(id).addEventListener('click', ()=>{
    if((id==='cardA' && current==='B')||(id==='cardB' && current==='A')) return;
    switchTurn(true);
  });
});

// Enter キーで手番切替
document.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); switchTurn(true); } });

// 初期化
buildSecSelect(q('byoyomiA')); buildSecSelect(q('byoyomiB'));
buildSecSelect(q('consA'));    buildSecSelect(q('consB'));
applyFromInputs(); updateSettingsUI(); updateUI();
</script>
{% endblock %}
